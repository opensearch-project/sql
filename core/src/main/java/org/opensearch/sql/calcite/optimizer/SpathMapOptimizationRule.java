/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 */

package org.opensearch.sql.calcite.optimizer;

import org.apache.calcite.plan.RelOptRule;
import org.apache.calcite.plan.RelOptRuleCall;
import org.apache.calcite.rel.RelNode;
import org.apache.calcite.rel.logical.LogicalProject;
import org.apache.calcite.rex.RexCall;
import org.apache.calcite.rex.RexNode;
import org.apache.calcite.sql.SqlOperator;
import org.opensearch.sql.calcite.utils.MapAccessOperations;

/**
 * Optimization rule for spath command MAP operations. This rule optimizes MAP access patterns
 * generated by dynamic columns, particularly for spath commands that use json_extract_all.
 */
public class SpathMapOptimizationRule extends RelOptRule {

  public static final SpathMapOptimizationRule INSTANCE = new SpathMapOptimizationRule();

  private SpathMapOptimizationRule() {
    super(operand(LogicalProject.class, any()), "SpathMapOptimizationRule");
  }

  @Override
  public boolean matches(RelOptRuleCall call) {
    LogicalProject project = call.rel(0);

    // Check if this project contains MAP access operations that could be optimized
    return project.getProjects().stream().anyMatch(this::isOptimizableMapAccess);
  }

  @Override
  public void onMatch(RelOptRuleCall call) {
    LogicalProject project = call.rel(0);
    RelNode input = project.getInput();

    // Create optimized project with improved MAP access patterns
    LogicalProject optimizedProject = createOptimizedProject(project, input);

    if (optimizedProject != null && !optimizedProject.equals(project)) {
      call.transformTo(optimizedProject);
    }
  }

  /** Check if a RexNode represents an optimizable MAP access operation. */
  private boolean isOptimizableMapAccess(RexNode node) {
    if (!(node instanceof RexCall)) {
      return false;
    }

    RexCall call = (RexCall) node;
    SqlOperator operator = call.getOperator();

    // Check for MAP access operations that can be optimized
    return operator.getName().equals("ITEM")
        && call.getOperands().size() == 2
        && isDynamicColumnsMapAccess(call);
  }

  /** Check if this is a MAP access on the _dynamic_columns field. */
  private boolean isDynamicColumnsMapAccess(RexCall call) {
    RexNode mapOperand = call.getOperands().get(0);

    // Check if the map operand references _dynamic_columns
    return mapOperand.toString().contains(MapAccessOperations.getDynamicColumnsFieldName());
  }

  /** Create an optimized version of the project with improved MAP access patterns. */
  private LogicalProject createOptimizedProject(LogicalProject originalProject, RelNode input) {
    // For now, return the original project
    // Future optimizations could include:
    // 1. Combining multiple MAP accesses into single operations
    // 2. Pushing MAP operations closer to data sources
    // 3. Caching frequently accessed MAP entries

    return originalProject;
  }
}
