setup:
  - do:
      query.settings:
        body:
          transient:
            plugins.calcite.enabled : true
  - do:
      bulk:
        index: test
        refresh: true
        body:
          - '{"index": {}}'
          - '{"log": "2024/05/08 01:50:22 [error] 29#29: *13323780 upstream timed out (110: Connection timed out) while reading response header from upstream, client: 10.0.1.151, server: , request: \"POST /api/checkout HTTP/1.1\", upstream: \"http://172.20.78.151:8080/api/checkout\", host: \"nginx-service:90\""}'
          - '{"index": {}}'
          - '{}'
          - '{"index": {}}'
          - '{"log": "not matched"}'

---
teardown:
  - do:
      query.settings:
        body:
          transient:
            plugins.calcite.enabled : false

---
"parse command matches substring":
  - skip:
      features:
        - headers
        - allowed_warnings
  - do:
      allowed_warnings:
        - 'Loading the fielddata on the _id field is deprecated and will be removed in future versions. If you require sorting or aggregating on this field you should also include the id in the body of your documents, and map this field as a keyword field that has [doc_values] enabled'
      headers:
        Content-Type: 'application/json'
      ppl:
        body:
          query: source=test | parse log 'request:\\s*\"(?<HttpRequest>.+?)\"' | fields HttpRequest

  - match: { total: 3 }
  - match: { "schema": [ { "name": "HttpRequest", "type": "string" }] }
  - match: {"datarows": [["POST /api/checkout HTTP/1.1"], [""], [""]]}
